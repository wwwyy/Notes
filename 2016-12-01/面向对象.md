## 面向对象
> - 是一种编程思想,每个角度不一样,理解也不一样(因为每个人的角度不同,看待同一个问题的结果就不同
> - 换了一种(写法)思想去写代码,可以在某个时间点上结果是一样,但是经过多次迭代结果一定不一样,用面向对象的写法会越写越简单,二把具有相同特征的代码抽离出来封装为一类,在这一类上扩充方法或者属性,让这个类(功能)更强大;
### js中的三大特征
>封装,继承,抽象,多态


----------
**属性一定是在某个(非空)对象上的.null(空对象),只有(非空)对象上才能加属性**
**属性或者方法前面都是有主的,都是挂在某个对象上的**
#### 构造函数
> 这个函数专门拿来构造一个对象的
#### 工厂函数
> 有原材料,有加工,有出厂的函数


----------
`new` :运算符---专门运算函数的;
> 用了`new`之后函数可以不用加括号就调用,new运算之后的()主要是为传参用的;
> `new`之后偷偷的在函数内容创建一个空白的对象
> `new`之后函数的默认返回值就为`new`出来的这个对象;
> `return`之后如果后面跟着为对象类型也包括函数,那么返回值就为`return`后面的值,否则就返回`new`出来的对象;

### 原型
>`prototype`:给某个类定义一个class;
>当一个函数被声明的时候,该函数下默认有一个属性:`prototype`;(该属性的值是一个**对象**)当我们去调用一个对象的属性或者方法的时候,如果该对象自身没有该属性或方法,则会调用到该对象的构造函数下的`prototype`下面属性或方法;
>`prototype`是给这个类的实例化对象使用的.(自身用不了)
>`_proto_`:原型链 对象有原型链(对象与构造函数原型的桥梁)
>对象没有原型只有链,函数有原型
>碰到对象找原型链,碰到函数找原型(始终要遵循,原型只给这个类的实例化对象用)
> **如果是对象,那么会先找链->构造函数的原型->构造函数的原型链->对象的原型**
> **如果是找函数:那么会先找链(因为函数的原型是给这个函数的实例化对象使用的)**

### 包装对象
> `str.length`->`new String()`->`length`->2个->`str`
> 当简单类型去查看某个属性或者方法的时候,系统会偷偷滴将这个简单类型转成对象类型的对象,从这个对象去查找要查看的结果,之后这个包装对象自动销毁;这个被销毁的对象为包装对象,整个过程就是简单类型也能查看(调用),某个属性或者方法的原理.
> 简单类型的属性只能读,不能写.`str.length=1`(这样是设置不了的)
> 就算是内置对象,也不能随意去修改属性,只能读;
#### 什么是包装对象
>当使用原始类型的值(`string,number,boolean`),在调用对应属性和方法的时候,内部会自动转成对应的对象.隐式创建的这个对象,就成为包装对象;
>内置的对象:`String,Number,Boolean`;
>包装对象的特点:隐式创建对象后,可以调用对应的属性和方法,使用后,立马销毁,所以不能给原始类型的值添加属性和方法;
>`String`-> 字符串
>`Array`-> 数组
>`Object`-> 对象
>`Number`-> 数字
>


----------


#### `hasOwnProperty`
>查看某个属性是不是这个对象自身的
>注意:**自身,一定是在当前这个对象中(不会沿着原型链查找属性,只查找自身属性)**


----------
#### for in
> -  因为简单类型的赋值就是赋值
> 简单类型的赋值是不会影响另一个数据
> - 而对象类型的复制是赋址
> 对象类型赋值都是引用一个内存地址,所以说,改变arr2,同样会改变arr
> - 解决
> 通过循环,将对象中每个简单类型赋值给另一个对象,就不会出现引用关系;